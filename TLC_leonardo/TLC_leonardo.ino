#include <SPI.h>

#include "Screen.h"

#define PIN_XLAT 2	// PD1
#define PIN_GSCLK 3 // generated by Timer2
#define PIN_VPRG 4	// PD4
#define PIN_BLANK 5 // PC6

const int num_tlcs = 1;

unsigned long prev_time = 0, new_time = 0;
byte dataDC[num_tlcs * 16]; // Dot Correction data, not tightly packed
const int g_screen_width = 5, g_screen_height = 1;
Screen my_screen(g_screen_width, g_screen_height, num_tlcs);

void setup()
{
	pinMode(PIN_XLAT, OUTPUT);
	pinMode(PIN_GSCLK, OUTPUT);
	pinMode(PIN_VPRG, OUTPUT);
	pinMode(PIN_BLANK, OUTPUT);

	SPI.begin();
	//SPI.setBitOrder(MSBFIRST);
	//SPI.setDataMode(SPI_MODE0);
	//SPI.setClockDivider(SPI_CLOCK_DIV4); // 16/4 = 4 MHz

	for (int i = 0; i < num_tlcs * 16; ++i)
	{
		if (i % 3 == 0) // r
			dataDC[i] = 63;
		else if (i % 3 == 1) // g
			dataDC[i] = 50;
		else // b
			dataDC[i] = 36;
		//dataDC[i] = 63;
	}

	Serial.begin(9600);

	setDotCorrection();

	cli(); // disable interrupts

	// Timer 1, data transfer to TLC
	TCCR1A = B00000000;
	TCCR1B = B00001100;

	// Timer 2, generates GSCLK for TLC
	TCCR0A = B00010010;
	TCCR0B = B00000001;

	TIMSK1 = B00000010;
	OCR1A = 15;

	sei(); // enable interrupts
}

void loop()
{
	new_time = millis();
	float dt = (new_time - prev_time) / 1000.0f;
	prev_time = new_time;

	updateAnimation(dt);

	my_screen.update();
}

/**
 * Updates animation according to time since last update.
 * The current animation is just signle diode "pixel"
 * ligting from left to right and bouncing from the sides.
 * 
 * @param dt delta time - time in seconds since last update
 */
void updateAnimation(float dt)
{
	static float pos = 0.0f;
	static float vel = 12.0f;
	static float sum_time = 0.0f;

	sum_time += dt;

	pos += vel * dt;

	if (pos < 0.0f)
	{
		pos = 1.0f;
		vel = -vel;
	}
	else if (pos >= (float)g_screen_width)
	{
		pos = (float)(g_screen_width - 1);
		vel = -vel;
	}

	clearScreen(0.0f, 0.0f, 0.0f);

	float r = (sin(sum_time) + 1.0f) / 2.0f;
	float g = (cos(sum_time * 0.5f) + 1.0f) / 2.0f;
	float b = (cos(sum_time * 0.25f) + 1.0f) * 0.5f / 2.0f;

	my_screen.pixel(pos, 0)->set_color(r * 0.3f, g * 0.3f, b * 0.3f);
	if (pos - 1.0f >= 0.0f)
		my_screen.pixel(pos - 1, 0)->set_color(r * 0.01f, g * 0.01f, b * 0.01f);
	if (pos + 1.0f < g_screen_width)
		my_screen.pixel(pos + 1, 0)->set_color(r * 0.01f, g * 0.01f, b * 0.01f);
}

void clearScreen(float r, float g, float b)
{
	for (int y = 0; y < g_screen_height; ++y)
		for (int x = 0; x < g_screen_width; ++x)
			my_screen.pixel(x, y)->set_color(r, g, b);
}

ISR(TIMER1_COMPA_vect)
{
	cli();
	// bitSet is a lot faster than digitalWrite but less convenient
	bitSet(PORTC, 6 /*PIN_BLANK*/);
	bitSet(PORTD, 1 /*PIN_XLAT*/);
	bitClear(PORTD, 1 /*PIN_XLAT*/);
	bitClear(PORTC, 6 /*PIN_BLANK*/);

	byte *dataToTransfer = my_screen.tlc_data();
	//Serial.println(my_screen.tlc_data_size());

	for (int i = my_screen.tlc_data_size() - 1; i >= 0; --i)
		SPI.transfer(dataToTransfer[i]);

	sei();
}

void setDotCorrection()
{
	bitSet(PORTD, 4 /*PIN_VPRG*/);

	int SPIByte = 0, SPIBit = 0;

	byte dataToTransfer[num_tlcs * 12];

	for (int i = 0; i < num_tlcs * 16; ++i)
	{
		for (int j = 0; j < 6; ++j, ++SPIBit)
		{
			if (SPIBit == 8)
			{
				SPIByte++;
				SPIBit = 0;
			}

			if (bitRead(dataDC[i], j))
				bitSet(dataToTransfer[SPIByte], SPIBit);
			else
				bitClear(dataToTransfer[SPIByte], SPIBit);
		}
	}

	SPI.begin();
	for (int i = SPIByte; i >= 0; --i)
		SPI.transfer(dataToTransfer[i]);

	SPI.end();

	bitSet(PORTD, 1 /*PIN_XLAT*/);
	bitClear(PORTD, 1 /*PIN_XLAT*/);

	bitClear(PORTD, 4 /*PIN_VPRG*/);
}
